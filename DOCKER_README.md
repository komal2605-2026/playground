# Docker Setup for User Management Backend

This guide explains how to run your Django User Management API using Docker.

## Prerequisites

- Docker installed: https://www.docker.com/products/docker-desktop
- Docker Compose installed (comes with Docker Desktop)

## Files Created

- **Dockerfile**: Defines how to build the Django app image
- **docker-compose.yml**: Orchestrates Django app + PostgreSQL database
- **entrypoint.sh**: Startup script that runs migrations and starts the server
- **.env**: Environment variables for Docker (local development)
- **.env.example**: Template file showing required environment variables
- **.dockerignore**: Specifies files to exclude from Docker build

## Quick Start

### 1. Build and Run Containers

```bash
# From the project root directory

# Build the Docker image
docker-compose build

# Start services (database + web app)
docker-compose up
```

The app will be available at `http://localhost:8000`

### 2. Access the Application

- **API Base URL**: http://localhost:8000
- **Django Admin**: http://localhost:8000/admin

## Common Docker Commands

### Start Services
```bash
docker-compose up
```

### Start Services in Background
```bash
docker-compose up -d
```

### Stop Services
```bash
docker-compose down
```

### View Logs
```bash
# View logs from all services
docker-compose logs -f

# View logs from specific service
docker-compose logs -f web      # Django app
docker-compose logs -f db       # PostgreSQL
```

### Access Container Shell
```bash
# Access Django app container
docker-compose exec web bash

# Access database container
docker-compose exec db psql -U postgres -d user_management_db
```

### Run Django Management Commands
```bash
# Create a superuser
docker-compose exec web python manage.py createsuperuser

# Run custom Django commands
docker-compose exec web python manage.py shell

# Check migrations
docker-compose exec web python manage.py showmigrations
```

### Force Rebuild (after dependency changes)
```bash
docker-compose build --no-cache
docker-compose up
```

## Environment Configuration

The `.env` file controls Docker configuration:

```env
# Django Settings
DEBUG=True                           # Set to False for production
SECRET_KEY=your-secret-key-here     # Change in production!
ALLOWED_HOSTS=localhost,127.0.0.1

# Database
DB_NAME=user_management_db
DB_USER=postgres
DB_PASSWORD=postgres               # Change in production!
DB_HOST=db                         # Use 'db' (Docker service name)
DB_PORT=5432
```

**⚠️ Important**: Change `SECRET_KEY` and `DB_PASSWORD` before production deployment!

## How It Works

1. **docker-compose.yml** defines two services:
   - **db**: PostgreSQL database with persistent volume
   - **web**: Your Django application

2. **Dockerfile** creates the Django app image:
   - Installs Python 3.14
   - Installs dependencies from requirements.txt
   - Copies your code
   - Uses Gunicorn as application server

3. **entrypoint.sh** runs when container starts:
   - Waits for database to be ready
   - Runs pending migrations
   - Collects static files
   - Starts Gunicorn server

## Volumes Explained

Three volumes handle data persistence:

1. **postgres_data**: Database storage
   - Survives container restarts
   - Data not lost when containers stop

2. **static_volume**: Django static files
   - CSS, JavaScript, images
   - Generated by `collectstatic`

3. **media_volume**: User uploaded files
   - Profile pictures, etc.
   - Survives container restarts

## Ports

- **8000**: Django app (http://localhost:8000)
- **5432**: PostgreSQL database (localhost:5432)

## Database Access

### From Docker Container
```bash
docker-compose exec db psql -U postgres -d user_management_db
```

### From Host Machine
```bash
# Install postgres client if needed
psql -h localhost -U postgres -d user_management_db
```

Connection Details:
- Host: localhost
- Port: 5432
- Database: user_management_db
- User: postgres
- Password: postgres (from .env file)

## Troubleshooting

### Port 8000 Already in Use
```bash
# Find what's using port 8000
lsof -i :8000

# Kill the process
kill -9 <PID>

# Or use different port in docker-compose.yml
# Change "8000:8000" to "8080:8000"
```

### Database Connection Issues
```bash
# Check if database is running
docker-compose logs db

# Restart specific service
docker-compose restart db
```

### Static Files Not Loading
```bash
# Collect static files manually
docker-compose exec web python manage.py collectstatic --noinput

# Check volume
docker volume inspect playground_static_volume
```

### Container Won't Start
```bash
# Check logs for errors
docker-compose logs web

# Verify ports aren't in use
docker ps

# Remove stopped containers
docker-compose down -v  # WARNING: Removes volumes (data loss!)
```

## Development Workflow

### Making Code Changes
1. Edit files locally (venv/bin/activate still works for local edits)
2. Docker watches for changes (due to volume mount)
3. Restart container if needed: `docker-compose restart web`

### Installing New Dependencies
1. Add package to `requirements.txt`
2. Rebuild container: `docker-compose build`
3. Restart: `docker-compose up`

### Database Migrations
```bash
# After model changes, create migration
docker-compose exec web python manage.py makemigrations

# Apply migration
docker-compose exec web python manage.py migrate
```

## Production Considerations

Before deploying to production:

1. **Change SECRET_KEY**: Generate a new one
   ```bash
   python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'
   ```

2. **Set DEBUG=False**: Never enable in production

3. **Change Database Password**: Use strong password

4. **Use Environment Secrets**: Store sensitive data securely (AWS Secrets Manager, etc.)

5. **Setup Nginx Reverse Proxy**: For serving static files and proxying requests

6. **Use Production Database**: PostgreSQL with backups

7. **Enable HTTPS**: Use Let's Encrypt certificates

8. **Configure ALLOWED_HOSTS**: Only your domain(s)

## Useful Resources

- Docker Docs: https://docs.docker.com/
- Docker Compose Docs: https://docs.docker.com/compose/
- Django Deployment: https://docs.djangoproject.com/en/6.0/howto/deployment/
- Gunicorn Docs: https://docs.gunicorn.org/

## Next Steps

1. Test locally with Docker
2. Verify all API endpoints work
3. Test user registration and login
4. Set up CI/CD pipeline
5. Deploy to cloud provider (AWS, Heroku, DigitalOcean, etc.)

---

Need help? Check logs with: `docker-compose logs -f web`
